<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <script type="text/javascript" src="http://latex.codecogs.com/latexit.js"></script>
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Map Projections: Challenging Pierceptions by jkunimune15</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>Map Projections</h1>
          <h2>Challenging Pierceptions</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/jkunimune15/Map-Projections/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/jkunimune15/Map-Projections/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/jkunimune15/Map-Projections" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>
        
        <font size="4"><a href="index.html" style="color:Gray">Home</a> | <a href="projections.html" style="color:Gray">Projections</a> | <font style="color:#A0A0A0;">Math</font> | <a href="aboutme.html" style="color:Gray">About Me</a></font>

        <hr>

        <section id="main_content">
          <h1>
            <a id="map-projections" class="anchor" href="#map-projections" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Math
          </h1>

          <p>This program makes use of some pretty cool math, if I do say so myself. Most of the equations came straight from Wikipedia, but many of the more complicated ones I had to derive myself. Here I detail all of my equations. As a convention, I always use &phi; and &lambda; for latitude and longitude respectively in radians measured from the equator where north and east are positive, r and &theta; for planar polar coordinates where &theta; is in radians measured counterclockwise from the bottom of the unit circle, and x and y for general cartesian coordinates.</p>

          <h2>Oblique aspect equations</h2>
          <p>
            The first thing I derived was the oblique map projection equation, used to transform a latitude and longitude to be relative to an arbitrary pole. There are a lot of holes and signs that you have to keep track of when computing it, but for the sake of simplicity, I'll just give you the basic equations. First, the forward equations, used to get relative spherical coordinates given absolute spherical coordinates and the pole:
          </p>
          <p lang="latex">
            \phi_r = \arcsin{[\sin\phi_P\sin\Phi+\cos\phi_P\cos\Phi\cos{(\lambda_P-\Lambda)}]}
          </p>
          <p lang="latex">
            \lambda_r = \pm\arccos\left[\frac{\sin\phi_P\cos\Phi\cos{(\lambda_P-\Lambda)}-\cos\phi_P\sin\Phi}{\cos\phi_r}\right]
          </p>
          <p>
            For raster maps, you need the inverse of these equations, which gives the absolute coordinates given some relative spherical coordinates and the pole:
          </p>
          <p lang="latex">
            \Phi = \arcsin[\sin\phi_P\,\sin\phi_r+\cos\phi_P\,\cos\phi_r\,\cos(\lambda_P-\lambda_r)]
          </p>
          <p lang="latex">
            \Lambda = \lambda_P\pm\arccos\left(\frac{\sin\phi_1}{\cos\phi_P\,\cos\Phi}-\tan\phi_P\,\tan\Phi\right)
          </p><!--TODO check that parethesis and brackets match, get rid of unnecessary \left and \right-->

          <h2>Projection analysis</h2>
          <p>
            The MapAnalyzer, MapPlotter, and MapOptimizer all use the same formulae for quantifying the distortion in a map. I concocted these metrics myself, but I think anyone will find that they are logical ways to rank a map projection, and they fit pretty nicely with my intuition of how good a map projection is.
          </p>
          <p>
            Characterising size distortion is quite simple. The scale at any point on the sphere is given by
          </p>
          <p lang="latex">
            \frac{A}{a} = \left(\frac{\partial{x}}{\partial{\lambda}}\frac{\partial{y}}{\partial{\phi}}-\frac{\partial{x}}{\partial{\phi}}\frac{\partial{y}}{\partial{\lambda}}\right)\sec{\phi}
          </p>
          <p>
            The average size distortion, then, is given by the standard deviation of the log of scale,
          </p>
          <p lang="latex">
            D_\mathrm{size} = \sqrt{\left<\left(\ln{\frac{A}{a}}-\left<\ln{\frac{A}{a}}\right>\right)^2\right>}
          </p>
          <p>
            The shape distortion is measured in a similar fashion. The stretch factor at any point is given by the formula
          </p>
          <p lang="latex">
            \sigma_1+\sigma_2 = \sqrt{\left(\frac{\partial{x}}{\partial{\lambda}}\sec{\phi}+\frac{\partial{y}}{\partial{\phi}}\right)^2+\left(\frac{\partial{x}}{\partial{\phi}}-\frac{\partial{y}}{\partial{\lambda}}\sec{\phi}\right)^2}
          </p>
          <p lang="latex">
            \sigma_1-\sigma_2 = \sqrt{\left(\frac{\partial{x}}{\partial{\lambda}}\sec{\phi}-\frac{\partial{y}}{\partial{\phi}}\right)^2+\left(\frac{\partial{x}}{\partial{\phi}}+\frac{\partial{y}}{\partial{\lambda}}\sec{\phi}\right)^2}
          </p>
          <p lang="latex">
            \frac{\sigma_1}{\sigma_2} = \frac{(\sigma_1+\sigma_2)+(\sigma_1-\sigma_2)}{(\sigma_1+\sigma_2)-(\sigma_1-\sigma_2)}
          </p>
          <p>
            The average shape distortion is then defined as the mean of the log of stretch,
          </p>
          <p lang="latex">
            D_\mathrm{shape} = \left<\left|\ln{\frac{\sigma_1}{\sigma_2}}\right|\right>
          </p>

          <h2>Invented projections</h2>
          <p>
            Now for the projections I've invented. As before, I will let it be known that these equations are riddled with holes. I don't want to explain all of them, so if it matters to you, you can solve the limits yourself.
          </p>
          <p>
            First is Pseudostereographic. If you are familiar with Hammer and Aitoff, this will probably be quite simple for you:
          </p>
          <p lang="latex">
            x = \mathrm{I'll simplify and transcribe this later}
          </p>
          <p lang="latex">
            y = \mathrm{Just go read about how Hammer and Azimuthal work}
          </p>
          <p>
            Slightly more complicated is the Hyperellipower projection. It is a pseudocylindrical projection with the shape of a hyperellipse and a power function controlling the parallel distance from equator. The equations work out to
          </p>
          <p lang="latex">
            y' = 1 - \left(1-\left|\frac{\phi}{\pi/2}\right|\right)^n
          </p>
          <p lang="latex">
            x = \sqrt[k]{1 - y'^k}*\frac{\lambda}{\pi}
          </p>
          <p lang="latex">
            y = \frac{ay'}{2\sqrt{n}}*\mathrm{signum}\,\phi
          </p>
          <p>
            Or, in inverse form,
          </p>
            <p lang="latex">
            \phi = \frac{\pi}{2}\left[1 - (1-|y|)^\frac{1}{n}\right]*\mathrm{signum}\,y
          </p>
          <p lang="latex">
            \lambda = \pi\frac{x}{\sqrt[k]{1 - |y|^k}}
          </p>
          <p>
            Next is the TetraGraph, an equidistant tetrahedral projection. Before applying the projection, one must first divide the sphere into four equally spaced, equally sized, and equally shaped quadrants &ndash; one for each face. Each quadrant must then be divided into three sectors depending on to which other face each point is closest. This projection is derived with a linear mapping from a &gamma;-&lambda; coordinate system on the sphere to an x-&theta; coordinate system on the plane.
          </p>
          <p>
            What are &gamma; and &lambda;, you ask? &lambda; is the azimuthal angle from the pole, or longitude, and &gamma; is the azimuthal angle from a point transverse to the pole, which I call the Justitude. This coordinate system, which I dub Justesian coordinates, breaks down on the orthodrome containing the pole and the Justimuth. Luckily, TetraGraph does not use this part of the sphere, because for a given sector, the azimuth is defined as the center of that sector's quadrant, and the Justimuth is defined equidistant from the centers of the two nearest quadrants. Furthermore, &lambda; is zero on the orthodrome connecting the centers of the two nearest quadrants and &gamma; is zero on the orthodrome connecting the pole and the Justimuth. With this coordinate system in mind (and the hopefully self-explanatory x-&theta; coordinate system), the projection inside each sector is defined as
          </p>
          <p lang="latex">
            x = \gamma
          </p>
          <p lang="latex">
            \theta = \lambda
          </p>
          <p>
            This renders each sector as an obtuse isoceles triangle. Three sector triangles tesselate into an equilateral triangle, and these quadrant triangles can the be tesselated however the cartographer sees fit. If you would prefer latitude to Justitude and r to x, use the expansion
          </p>
          <p lang="latex">
            r = \arctan(\cot\phi\cos\lambda)\sec\lambda
          </p>
          <p lang="latex">
            \phi = \tan(r\cos\lambda)\sec\lambda
          </p>
          <p>
            Next is TetraPower, almost identical to TetraGraph save some power functions thrown in to make it more optimisable. The forward equations work out to
          </p>
          <p lang="latex">
            \theta = \frac{\pi}{3}*\frac{1-\left(\frac{\left|\lambda\right|}{\pi/2}\right)^{k_1}}{1-\left(\frac{1}{3}\right)^{k_1}}*\mathrm{signum}\lambda
          </p>
          <p lang="latex">
            k_R = k_3\frac{\left|\theta\right|}{\pi/3}+k_2\left(1-\frac{\left|\theta\right|}{\pi/3}\right)
          </p>
          <p lang="latex">
            r_\triangle = \frac{1}{2}\sec\theta
          </p>
          <p lang="latex">
            r_\circ = \frac{1}{\arctan\sqrt{2}}\arctan(\cot\phi\sec\lambda)*r_\triangle
          </p>
          <p lang="latex">
            r = \frac{1-(1-r_\circ)^{k_R}}{1-(1-r_\triangle)^{k_R}}*\frac{2}{3}r_\triangle
          </p>
          <p>
            The inverse equations are
          </p>
          <p lang="latex">
            \lambda = \left(1-\frac{3}{\pi}\left\{1-|\theta|\left[1-\left(\frac{1}{3}\right)^{k_1}\right]\right\}^\frac{1}{k_1}\right)*\frac{\pi}{2}\mathrm{signum}\,\theta
          </p>
          <p lang="latex">
            k_R = k_3\frac{\left|\theta\right|}{\pi/3}+k_2\left(1-\frac{\left|\theta\right|}{\pi/3}\right)
          </p>
          <p lang="latex">
            r_\triangle = \frac{1}{2}\sec{\theta}
          </p>
          <p lang="latex">
            r_\circ = 1 - \left\{\frac{r}{r_\triangle}\left[1-(1-r_\triangle)^{k_R}\right]\right\}^\frac{1}{k_R}
          </p>
          <p lang="latex">
            \phi=\arctan\left[\cos\lambda\cot\left(\frac{r_\circ}{r_\triangle}\arctan\sqrt{2}\right)\right]
          </p>
          <p>
            TetraFillet is similar to TetraPower, but the quadrants on the plane render as piecewise curves rather than simple triangles. The equations are the same as those for TetraPower, save the following substitution:
          </p>
          <p lang="latex">
            r_\triangle=\left\{\begin{array}{ll}
              \frac{1}{2}\sec\theta, &amp; |\theta| &lt; 0.70123892\\
              \\
              \frac{3}{4}-0.79863870\left(\frac{\pi}{3}-|\theta|\right)^2, &amp; |\theta|\ge0.70123892
            \end{array}\right.
          </p>
          <p>
            Finally, we have Two-point Equalised, based heavily on Two-point Equidistant. The forward equations work out as follows:
          </p>
          <p lang="latex">
            x = \mathrm{I'll simplify all this later}
          </p>
          <p lang="latex">
            y = 
          </p>
          <p>
            The inverse is:
          </p>
          <p lang="latex">
            \phi = 
          </p>
          <p lang="latex">
            \lambda = 
          </p>
        </section>

        <footer>
          Map Projections: Challenging Pierceptions is maintained by <a href="https://github.com/jkunimune15">jkunimune15</a><br>
          This page was generated by <a href="https://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

      </div>
    </div>
  </body>
</html>
